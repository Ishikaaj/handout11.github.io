<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ishika Jaisingh">
<meta name="dcterms.date" content="2024-12-05">

<title>How Sure Can We Be About What Is Going On? – handoutfinal.github.io</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-07ba0ad10f5680c660e360ac31d2f3b6.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-8bda806db8b623a4dafb352339cca83f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">handoutfinal.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" aria-current="page"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">How Sure Can We Be About What Is Going On?</h1>
<p class="subtitle lead">Data Science for Business (SS 2024)</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ishika Jaisingh <a href="mailto:jaisingh.ishika@stud.hs-fresenius.de" class="quarto-title-author-email"><i class="bi bi-envelope"></i></a> </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">December 5, 2024</p>
    </div>
  </div>
  
    
  </div>
  
<div>
  <div class="abstract">
    <div class="block-title">Abstract</div>
    A fundamental component of statistical analysis, uncertainty influences how we understand data and make inferences. Because estimates based on sample data are inherently imperfect, statistical procedures are necessary to accurately measure and convey uncertainty. Important approaches like margins of error, bootstrapping, and confidence intervals are examined in this handout. The crucial difference between aleatory uncertainty—which results from randomness—and epistemic uncertainty—which results from knowledge gaps—is also covered. The handbook emphasizes practical uses in scientific research, policy-making, and surveys while stressing the value of statistical literacy and ethical data interpretation.
  </div>
</div>


</header>


<p>Heading</p>
<p>Understanding Uncertainty and Statistical Inference: A Comprehensive Guide</p>
<p>Introduction</p>
<p>Uncertainty is not just a flaw in statistical analysis but an internal feature. It reflects the limitations of what we know and what is the variability in the case we study. Estimates derived from sample data are rarely exact representations of the population and are subject to variability due to randomness and measurement errors. Statistical tools help quantify uncertainty, offering transparency and allowing analysts to communicate findings responsibly (Spiegelhalter, 2019).</p>
<p>Concepts such as confidence intervals, margins of error, and bootstrapping are vital to navigating uncertainty. Furthermore, distinguishing between aleatory uncertainty, which arises from inherent randomness, and epistemic uncertainty, starting from incomplete knowledge, helps researchers contextualize variability and address its sources effectively (Ferson et al., 2004). This paper presents these methods and concepts, emphasizing their theoretical and practical implications across different fields, including policy-making, survey design, and scientific research.</p>
<p>Confidence Intervals: Quantifying Uncertainty</p>
<p>One of the most popular methods for expressing uncertainty in estimations is the use of confidence intervals (CIs). Based on sample data, they offer a range of values for an unknown population parameter. The genuine amount of support is probably between 56% and 64%, for example, if a survey indicates that 60% of respondents approve a program with a 95% confidence interval of ±4%. Because they take sample variability into account, confidence intervals provide a more sophisticated understanding than single-point estimates. (Wasserman, 2013).</p>
<p>How Confidence Intervals Work</p>
<p>Confidence intervals rely on the principle of sampling variability. No single sample can perfectly decipher a population, but repeated sampling produces a predictable pattern. CIs are constructed to capture the true population parameter within the interval a specified percentage of the time, such as 95% (Spiegelhalter, 2019).</p>
<p>Key Factors Affecting Confidence Intervals</p>
<p>Sample size: Larger samples lead to narrower intervals because they reduce variability.</p>
<p>Variability within the data: Greater variability produces wider intervals.</p>
<p>Confidence level: Higher confidence levels (e.g., 99%) result in wider intervals to increase the likelihood of capturing the true value.</p>
<p>Example</p>
<p>Consider a poll estimating that 55% of voters favor a candidate, with a 95% CI of ±3%. This suggests that, based on the data, there is a high probability the true support lies between 52% and 58%.</p>
<p>Margins of Error: Understanding Sampling Variability</p>
<p>In survey reports, margins of error are frequently employed to measure uncertainty brought on by sample variability. They illustrate the reliability of the estimate by indicating the range that the true population parameter most likely falls within (Groves et al., 2009).</p>
<p>How Margins of Error Are Calculated</p>
<p>Margins of error depend on:</p>
<p>Sample size: Larger samples reduce the margin of error. Population variability: Higher variability increases the margin of error.</p>
<p>Confidence level: Similar to confidence intervals, higher levels of confidence lead to larger margins of error. Example Suppose a survey reports that 40% of respondents support a policy with a margin of error of ±5%. This implies the true support level in the population likely falls between 35% and 45%, considering the sampling process.</p>
<p>Applications in Policy</p>
<p>Making In policy contexts, small shifts in estimates can lead to significant decisions. For example, minor fluctuations in unemployment rates may not represent real changes but fall within the margin of error (Spiegelhalter, 2019). Decision-makers must consider these margins to avoid over-interpreting the data.</p>
<p>Bootstrapping: A Resampling Method</p>
<p>Resampling the data is a step in the bootstrapping process that evaluates a statistic’s variability. It provides an empirical distribution of the statistic without relying on strict population assumptions (Efron &amp; Tibshirani, 1994).</p>
<p>How Bootstrapping Works</p>
<p>Draw repeated samples, with replacement, from the observed data.</p>
<p>Compute the desired statistic (e.g., mean or median) for each sample.</p>
<p>Analyze the distribution of these statistics to estimate variability.</p>
<p>Advantages</p>
<p>Effective for small samples where traditional parametric methods may fail.</p>
<p>Does not require normality or other specific assumptions.</p>
<p>Example</p>
<p>Suppose a sample of 10 students has an average test score of 75. Bootstrapping generates multiple “new” samples from the original data and calculates the mean for each. The distribution of these means provides insight into the variability of the original estimate.</p>
<p>Aleatory vs.&nbsp;Epistemic Uncertainty</p>
<p>Understanding the sources of uncertainty is crucial for addressing it effectively. Spiegelhalter (2019) emphasizes that recognizing whether uncertainty arises from randomness or knowledge gaps can guide better analysis and decision-making.</p>
<p>Aleatory Uncertainty</p>
<p>Aleatory uncertainty reflects the natural variability of a process or system. It is irreducible, as it is inherent to the phenomenon itself. Probabilistic models are used to characterize this type of uncertainty. For instance, rolling a die or flipping a coin involves aleatory uncertainty because the outcomes are purely random and follow predictable probability distributions (Spiegelhalter, 2019).</p>
<p>Examples:</p>
<p>Rolling a Dice: Each roll produces one of six outcomes with equal likelihood. This randomness cannot be reduced but is well-understood probabilistically.</p>
<p>Weather Patterns: Day-to-day weather variability, such as fluctuating temperatures, is an example of aleatory uncertainty inherent to atmospheric dynamics.</p>
<p>Epistemic Uncertainty</p>
<p>Epistemic uncertainty arises from limited knowledge about a system or process. Unlike aleatory uncertainty, it is potentially reducible with better data, improved models, or refined measurement techniques (Ferson et al., 2004). Bayesian approaches are often used to incorporate and update knowledge in the presence of epistemic uncertainty.</p>
<p>Examples:</p>
<p>Estimating Fish Populations: A lake survey may estimate fish numbers based on a small sample, but limited data introduces epistemic uncertainty. Additional sampling could improve the accuracy of the estimate.</p>
<p>Predicting System Failures: A new machine’s failure rate might be uncertain due to limited operational data. More extensive testing could reduce this uncertainty.</p>
<p>Comparing Aleatory and Epistemic Uncertainty</p>
<p>Aspect</p>
<p>Aleatory</p>
<p>Epistemic</p>
<p>Source</p>
<p>Inherent randomness</p>
<p>Lack of knowledge</p>
<p>Reducibility</p>
<p>Irreducible</p>
<p>Reducible</p>
<p>Modeling Approach</p>
<p>Probability distributions</p>
<p>Bayesian inference, model refinement</p>
<p>Combined Uncertainty: Real-World Scenarios In practice, both aleatory and epistemic uncertainties often coexist:</p>
<p>Weather Forecasting:</p>
<p>Aleatory: Randomness in weather systems (e.g., turbulence). Epistemic: Limited observational data or imperfect models (Spiegelhalter, 2019).</p>
<p>Health Risk Assessment:</p>
<p>Aleatory: Individual differences in drug response. Epistemic: Limited trial data on long-term effects.</p>
<p>An Extensive Guide on Statistical Inference and Uncertainty Understanding Abstraction A fundamental component of statistical analysis, uncertainty influences how we understand data and make inferences. Because estimates based on sample data are inherently imperfect, statistical procedures are necessary to accurately measure and convey uncertainty. Important approaches like margins of error, bootstrapping, and confidence intervals are examined in this handout. The crucial difference between aleatory uncertainty—which results from randomness—and epistemic uncertainty—which results from knowledge gaps—is also covered. The handbook emphasizes practical uses in scientific research, policy-making, and surveys while stressing the value of statistical literacy and ethical data interpretation.For managing uncertainty, ideas like bootstrapping, margins of error, and confidence intervals are crucial. Additionally, researchers can better contextualize variability and address its sources by differentiating between aleatory uncertainty, which results from innate randomness, and epistemic uncertainty, which results from imperfect knowledge (Ferson et al., 2004). This book emphasizes the theoretical and practical consequences of these approaches and concepts in a variety of domains, including as scientific research, survey design, and policy-making, while presenting them in an approachable manner.</p>
<p>Quantifying Uncertainty with Confidence Intervals One of the most popular methods for expressing uncertainty in statistical estimations is the use of confidence intervals (CIs). Based on sample data, they offer a range of reasonable values for an unknown population parameter. The genuine amount of support is probably between 56% and 64%, for example, if a survey indicates that 60% of respondents approve a program with a 95% confidence interval of ±4%. Because they take sample variability into account, confidence intervals provide a more sophisticated understanding than single-point estimates (Wasserman, 2013).</p>
<p>How Confidence Intervals Work Confidence intervals rely on the principle of sampling variability. No single sample perfectly represents a population, but repeated sampling produces a predictable pattern. CIs are constructed to capture the true population parameter within the interval a specified percentage of the time, such as 95% (Spiegelhalter, 2019).</p>
<p>Key Factors Affecting Confidence Intervals Sample size: Larger samples lead to narrower intervals because they reduce variability. Variability within the data: Greater variability produces wider intervals. Confidence level: Higher confidence levels (e.g., 99%) result in wider intervals to increase the likelihood of capturing the true value. Example Consider a poll estimating that 55% of voters favor a candidate, with a 95% CI of ±3%. This suggests that, based on the data, there is a high probability the true support lies between 52% and 58%.</p>
<p>Margins of Error: Understanding Sampling Variability Margins of error are widely used in survey reports to quantify uncertainty due to sampling variability. They indicate the range within which the true population parameter likely lies, reflecting the reliability of the estimate (Groves et al., 2009).</p>
<p>How Margins of Error Are Calculated Margins of error depend on:</p>
<p>Sample size: Larger samples reduce the margin of error. Population variability: Higher variability increases the margin of error. Confidence level: Similar to confidence intervals, higher levels of confidence lead to larger margins of error. Example Suppose a survey reports that 40% of respondents support a policy with a margin of error of ±5%. This implies the true support level in the population likely falls between 35% and 45%, considering the sampling process.</p>
<p>Applications in Policy-Making In policy contexts, small shifts in estimates can lead to significant decisions. For example, minor fluctuations in unemployment rates may not represent real changes but fall within the margin of error (Spiegelhalter, 2019). Decision-makers must consider these margins to avoid overinterpreting the data.</p>
<p>A Bootstrapping Method for Resampling the observed data, is used to evaluate the variability of a statistic. Without depending on rigid demographic assumptions, it offers an empirical distribution of the statistic (Efron &amp; Tibshirani, 1994).</p>
<p>How Bootstrapping Works Draw repeated samples, with replacement, from the observed data. Compute the desired statistic (e.g., mean or median) for each sample. Analyze the distribution of these statistics to estimate variability. Advantages Effective for small samples where traditional parametric methods may fail. Does not require normality or other specific assumptions. Example Suppose a sample of 10 students has an average test score of 75. Bootstrapping generates multiple “new” samples from the original data and calculates the mean for each. The distribution of these means provides insight into the variability of the original estimate.</p>
<p>Aleatory versus Epistemic Uncertainty Understanding the sources of uncertainty is essential to handling it effectively. Spiegelhalter (2019) emphasizes that determining whether uncertainty stems from randomness or knowledge gaps can help with improved analysis and decision-making.</p>
<p>Aleatory Uncertainty Aleatory uncertainty stems from inherent randomness in a system. It is irreducible but can be modeled probabilistically.</p>
<p>Examples:</p>
<p>Rolling a dice: Each roll has an equal probability, and outcomes are inherently random. Flipping a coin: The probability of heads or tails remains constant. Epistemic Uncertainty Epistemic uncertainty arises from incomplete knowledge or data. Unlike aleatory uncertainty, it can often be reduced by improving models or collecting more information (Ferson et al., 2004).</p>
<p>Examples:</p>
<p>Estimating the average number of fish in a lake with incomplete survey data. Predicting the lifespan of a new product with limited testing. Combined Uncertainty In some scenarios, both forms of uncertainty coexist. For instance, weather forecasting involves aleatory uncertainty (natural randomness) and epistemic uncertainty (limited observations and model errors) (Spiegelhalter, 2019).</p>
<p>Practical Applications</p>
<p>Survey-Based Estimates</p>
<p>Surveys aim to generalize findings to a larger population, but errors in sampling and response bias can complicate interpretation. Techniques like bootstrapping and applying the Central Limit Theorem improve reliability (Lumley, 2010).</p>
<p>Policy-Making</p>
<p>In policy contexts, quantifying uncertainty helps prevent overconfidence in data-driven decisions. For instance, reporting confidence intervals alongside economic indicators enables stakeholders to understand the range of possible outcomes.</p>
<p>Discussion</p>
<p>In order to practice statistics responsibly, uncertainty must be quantified and communicated. Although they need to be interpreted carefully, tools like bootstrapping, margins of error, and confidence intervals provide insightful information on variability. Particularly in important fields like public policy, healthcare, and climate research, poor communication can result in poor decisions.To identify uncertainty and correctly interpret data, one must be statistically literate. To promote well-informed decision-making, analysts, educators, and decision-makers must highlight the probabilistic nature of findings (Spiegelhalter, 2019).</p>
<p>Conclusion</p>
<p>In statistical analysis, uncertainty is inevitable, but it can be efficiently addressed with the right tools. Robust conclusions are made possible by confidence intervals, margins of error, and resampling techniques like bootstrapping, and variability is better understood by differentiating between aleatory and epistemic uncertainty. Accepting uncertainty encourages humility and accuracy in data analysis, which increases the validity of findings from various fields.</p>
<p>References</p>
<p>Efron, B., &amp; Tibshirani, R. J. (1994). An Introduction to the Bootstrap. CRC Press.</p>
<p>Ferson, S., Ginzburg, L. R., &amp; Goldstein, M. (2004). Aleatory and epistemic uncertainty in probability assessment. Risk Analysis, 24(1), 25-34.</p>
<p>Groves, R. M., Fowler, F. J., Couper, M. P., Lepkowski, J. M., Singer, E., &amp; Tourangeau, R. (2009). Survey Methodology. Wiley.</p>
<p>Lumley, T. (2010). Complex Surveys: A Guide to Analysis Using R. Wiley.</p>
<p>Spiegelhalter, D. (2019). The Art of Statistics: Learning from Data. Pelican.</p>
<p>Wasserman, L. (2013). All of Statistics: A Concise Course in Statistical Inference. Springer.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>